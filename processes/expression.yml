# ==================================
# Processors for expression profiles
# ==================================
#
# Processors for computing the gene expression profile of NGS data.
---

- name: expression:bcm-1-0-0
  version: 1.0.10
  label: Expression (BCM)
  type: data:expression:polya
  category: analyses
  persistence: CACHED
  description: >
    Compute gene expression profile. Developed by Bioinformatics Laboratory, Faculty of Computer and Information Science,
    University of Ljubljana, Slovenia and Shaulsky Lab, Department of Molecular and Human Genetics, Baylor College of
    Medicine, Houston, TX, USA.
  input:
    - name: alignment
      label: Aligned sequence
      type: data:alignment:bam
      required: true
    - name: gff
      label: Features (GFF3)
      type: data:annotation:gff3
      required: true
    - name: mappable
      label: Mappability
      type: data:mappability:bcm
      required: true
  output:
    - name: exp
      label: Expression RPKUM (polyA)
      type: basic:file
      description: mRNA reads scaled by uniquely mappable part of exons.
    - name: rpkmpolya
      label: Expression RPKM (polyA)
      type: basic:file
      description: mRNA reads scaled by exon length.
    - name: rc
      label: Read counts (polyA)
      type: basic:file
      description: mRNA reads uniquely mapped to gene exons.
    - name: rpkum
      label: Expression RPKUM
      type: basic:file
      description: Reads scaled by uniquely mappable part of exons.
    - name: rpkm
      label: Expression RPKM
      type: basic:file
      description: Reads scaled by exon length.
    - name: rc_raw
      label: Read counts (raw)
      type: basic:file
      description: Reads uniquely mapped to gene exons.
    - name: exp_json
      label: Expression RPKUM (polyA) (json)
      type: basic:json
    - name: exp_type
      label: Expression Type (default output)
      type: basic:string
      default: polyA
  static:
    - name: name
      label: Name
      type: basic:string
      default: "Gene expressions ({{ alignment.output.bam.file|basename|default:'?' }})"
    - name: alias
      label: Alias
      type: basic:string
      description: Short name for the expression analysis
    - name: cite
      label: Citation
      type: list:basic:url:link
    - name: experiment
      label: Experiment
      type: basic:string
    - name: attachments
      label: Attachments
      type: list:basic:file
    - name: tags
      label: Tags
      type: list:basic:string
      default: ["expression", "profiles"]
      placeholder: new tag
    - name: description
      label: Description
      type: basic:text
      default: "Description of {{ alignment.output.bam.file|basename|default:'?' }} gene expression."
  var:
    - name: notes
      label: Notes
      type: basic:text
  run:
    runtime: polyglot
    bash: |
      gen-require common
      gen-require samtools-0.1.19
      gen-require kentUtils-2.9.1

      NAME=`basename '{{ alignment.bam.file }}' .bam`

      function compute_coverage {
        xtabcoverage.py --tab "{{ proc.data_path }}/{{ proc.data_id }}/${1}" --tab-coverage-col 1 --gff3 "{{ gff.gff.file }}" > tmp.bedgraph
        bedGraphToBigWig tmp.bedgraph chrom.sizes "${1}.bw"
        rm tmp.bedgraph
      }

      echo "XEXPRESSION..."
      xexpression.py "{{ gff.gff.file }}" "{{ alignment.bam.file }}" --rc --rpkm --rpkum {{mappable.mappability.file}}
      gen-checkrc
      gen-progress 0.5

      xexpression.py "{{ gff.gff.file }}" "{{ alignment.bam.file }}" --rc --rpkm --rpkum {{mappable.mappability.file}} --mrna
      samtools idxstats "{{ alignment.bam.file }}" | cut -f -2 | head -n -1 > chrom.sizes

      if [ -f {{ proc.data_path }}/{{ proc.data_id }}/expression_rc.tab.gz ]
      then
        mv expression_rc.tab.gz ${NAME}_expression_rc.tab.gz
        compute_coverage ${NAME}_expression_rc.tab.gz
        gen-checkrc
        gen-save-file rc_raw ${NAME}_expression_rc.tab.gz ${NAME}_expression_rc.tab.gz.bw
      fi
      if [ -f {{ proc.data_path }}/{{ proc.data_id }}/expression_rc_polya.tab.gz ]
      then
        mv expression_rc_polya.tab.gz ${NAME}_expression_rc_polya.tab.gz
        compute_coverage ${NAME}_expression_rc_polya.tab.gz
        gen-checkrc
        gen-save-file rc ${NAME}_expression_rc_polya.tab.gz ${NAME}_expression_rc_polya.tab.gz.bw
      fi
      if [ -f {{ proc.data_path }}/{{ proc.data_id }}/expression_rpkm.tab.gz ]
      then
        mv expression_rpkm.tab.gz ${NAME}_expression_rpkm.tab.gz
        compute_coverage ${NAME}_expression_rpkm.tab.gz
        gen-checkrc
        gen-save-file rpkm ${NAME}_expression_rpkm.tab.gz ${NAME}_expression_rpkm.tab.gz.bw
      fi
      if [ -f {{ proc.data_path }}/{{ proc.data_id }}/expression_rpkm_polya.tab.gz ]
      then
        mv expression_rpkm_polya.tab.gz ${NAME}_expression_rpkm_polya.tab.gz
        compute_coverage ${NAME}_expression_rpkm_polya.tab.gz
        gen-checkrc
        gen-save-file rpkmpolya ${NAME}_expression_rpkm_polya.tab.gz ${NAME}_expression_rpkm_polya.tab.gz.bw
      fi
      if [ -f {{ proc.data_path }}/{{ proc.data_id }}/expression_rpkum.tab.gz ]
      then
        mv expression_rpkum.tab.gz ${NAME}_expression_rpkum.tab.gz
        compute_coverage ${NAME}_expression_rpkum.tab.gz
        gen-checkrc
        gen-save-file rpkum ${NAME}_expression_rpkum.tab.gz ${NAME}_expression_rpkum.tab.gz.bw
      fi
      if [ -f {{ proc.data_path }}/{{ proc.data_id }}/expression_rpkum_polya.tab.gz ]
      then
        mv expression_rpkum_polya.tab.gz ${NAME}_expression_rpkum_polya.tab.gz
        compute_coverage ${NAME}_expression_rpkum_polya.tab.gz
        gen-checkrc
        expression2storage.py ${NAME}_expression_rpkum_polya.tab.gz
        gen-checkrc
        gen-save-file exp ${NAME}_expression_rpkum_polya.tab.gz ${NAME}_expression_rpkum_polya.tab.gz.bw
      fi

- name: mergeexpressions
  version: 1.0.5
  label: Merge Expressions
  type: data:expressionset
  category: analyses
  persistence: CACHED
  description: >
    Merge expression data and filter genes.
  input:
    - name: exps
      label: Gene expressions
      type: list:data:expression
      required: true
    - name: genes
      label: Filter genes
      type: list:basic:string
      required: false
      default: ['DDB_G0267184', 'DDB_G0267188', 'DDB_G0267204']
  output:
    - name: expset
      label: Expression set
      type: basic:file
    - name: expset_type
      label: Expression set type
      type: basic:string
  static:
    - name: name
      label: Name
      type: basic:string
      default: "Merged expressions"
    - name: cite
      label: Citation
      type: list:basic:url:link
    - name: experiment
      label: Experiment
      type: basic:string
    - name: attachments
      label: Attachments
      type: list:basic:file
    - name: tags
      label: Tags
      type: list:basic:string
      default: ["expression"]
      placeholder: new tag
    - name: description
      label: Description
      type: basic:text
  var:
    - name: notes
      label: Notes
      type: basic:text
  run:
    runtime: polyglot
    bash: |
      gen-require common

      EXPSET_TYPE="{{ exps.0.output.exp_type }}"

      {% for e in exps %}
        {% if exps.0.output.exp_type != e.output.exp_type %}
          gen-error "Expressions must be of the same expression type"
        {% endif %}
      {% endfor %}

      python -u {{proc.slugs_path}}/gencloud-20131109/expressionmerge.py {% for e in exps %}"{{e.output.exp.file}}" {% endfor %} --experiments {% for e in exps %}"{{e|name}}" {% endfor %} {% if genes %}--genes {% for g in genes %}"{{g}}" {% endfor %}{% endif %} --intersection --out 'sample.tab'
      gen-checkrc
      gen-save expset_type "$EXPSET_TYPE"
      gen-save-file expset sample.tab

- name: mergeetc
  version: 1.0.3
  label: Merge Expressions (ETC)
  type: data:expressionset:etc
  category: analyses
  persistence: CACHED
  description: >
    Merge Expression Time Course (ETC) data.
  input:
    - name: exps
      label: Expression Time Course (ETC)
      type: list:data:etc
      required: true
    - name: genes
      label: Filter genes
      type: list:basic:string
      required: false
  output:
    - name: expset
      label: Expression set
      type: basic:file
    - name: expset_type
      label: Expression set type
      type: basic:string
  static:
    - name: name
      label: Name
      type: basic:string
      default: "Merged expressions"
    - name: cite
      label: Citation
      type: list:basic:url:link
    - name: experiment
      label: Experiment
      type: basic:string
    - name: attachments
      label: Attachments
      type: list:basic:file
    - name: tags
      label: Tags
      type: list:basic:string
      default: ["expression", "ETC"]
      placeholder: new tag
    - name: description
      label: Description
      type: basic:text
  var:
    - name: notes
      label: Notes
      type: basic:text
  run:
    runtime: polyglot
    bash: |
      gen-require common

      mergeetc.py {% for e in exps %}"{{e.etcfile.file}}" {% endfor %} {% if genes %}--genes {% for g in genes %}"{{g}}" {% endfor %}{% endif %} --experiments {% for e in exps %}"{{e|name}}" {% endfor %} --out 'etc.tab'

      gzip 'etc.tab'
      gen-save-file expset 'etc.tab.gz'
      gen-save expset_type 'ETC'

- name: etc:bcm-1-0-0
  version: 1.0.10
  label: Expression Time Course
  type: data:etc
  category: analyses
  persistence: CACHED
  description: >
    Select gene expression data and form a time course.
  input:
    - name: expressions
      label: RPKM expression profile
      type: list:data:expression
      required: true
    - name: avg
      label: Average by time
      type: basic:boolean
      default: true
  output:
    - name: etcfile
      label: Expression time course file
      type: basic:file
    - name: etc
      label: Expression time course
      type: basic:json
  static:
    - name: name
      label: Experiment name
      type: basic:string
      default: "Expression time course"
    - name: alias
      label: Alias
      type: basic:string
      description: Short name for the expression time course.
    - name: cite
      label: Citation
      type: list:basic:url:link
    - name: experiment
      label: Experiment
      type: basic:string
    - name: attachments
      label: Attachments
      type: list:basic:file
    - name: tags
      label: Tags
      type: list:basic:string
      default: ["gene", "expression", "time", "course"]
      placeholder: new tag
    - name: description
      label: Description
      type: basic:text
      default: "Description of gene expression time course."
    - name: jbrowse_tracks
      label: Associated JBrowse tracks
      type: list:data:jbrowse
  var:
    - name: notes
      label: Notes
      type: basic:text
  run:
    runtime: polyglot
    bash: |
      gen-require common

      etc.py {% for e in expressions %}"{{e.exp.file}}" {% endfor %} --names {% for e in expressions %}"{{e|name}}" {% endfor %} {% if avg %}--mean{% endif %}
      gen-checkrc

      gen-save-file etcfile etc.json.gz

- name: differentialexpression:bcm-1-0-0
  version: 1.0.7
  label: Differential Expression (baySeq)
  type: data:differentialexpression:bayseq
  category: analyses
  persistence: CACHED
  description: >
    Find differentially expressed genes.
  input:
    - name: name
      label: Name
      type: basic:string
      required: true
    - name: case
      label: Case
      type: list:data:expression:polya
      required: true
    - name: control
      label: Control
      type: list:data:expression:polya
      required: true
    - name: replicates
      label: Replicates
      type: list:basic:string
      required: true
    - name: mappability
      label: Mappability
      type: data:mappability
      required: true
  output:
    - name: diffexp
      label: Differential expression
      type: basic:file
    - name: volcano_plot
      label: Volcano plot
      type: basic:json
  static:
    - name: name
      label: Name
      type: basic:string
      default: "{{ name }}"
    - name: alias
      label: Alias
      type: basic:string
      description: Short name for the DE analysis
    - name: cite
      label: Citation
      type: list:basic:url:link
    - name: experiment
      label: Experiment
      type: basic:string
    - name: attachments
      label: Attachments
      type: list:basic:file
    - name: tags
      label: Tags
      type: list:basic:string
      default: ["differential", "expression", "baySeq"]
      placeholder: new tag
    - name: description
      label: Description
      type: basic:text
      default: "Description of the differential expression."
  var:
    - name: notes
      label: Notes
      type: basic:text
  run:
    runtime: polyglot
    bash: |

      {% for c in case %}
        {% if not c.output.rc.file %}
          echo "{\"proc.error\":\"Read counts (polya) are required when using bayseq\"}"
        {% endif %}
      {% endfor %}

      {% for c in control %}
        {% if not c.output.rc.file %}
          echo "{\"proc.error\":\"Read counts (polya) are required when using bayseq\"}"
        {% endif %}
      {% endfor %}

      python -u {{ proc.slugs_path }}/gencloud-20131109/expressionmerge.py {% for c in case %}"{{c.output.rc.file}}" {% endfor %} {% for c in control %}"{{c.output.rc.file}}" {% endfor %} --experiments {% for c in case %}"Case_Counts_{{c.id}}" {% endfor %} {% for c in control %}"Control_Counts_{{c.id}}" {% endfor %} > expressions.tab
      echo "{\"proc.progress\":0.1,\"proc.rc\":$?}"

      Rscript {{ proc.slugs_path }}/gencloud-20131109/run_bayseq.R expressions.tab {{mappability.output.mappability.file}} --groups {% for c in case %}1 {% endfor %}{% for c in control %}2 {% endfor %} --replicates {% if replicates %}{% for r in replicates %}{{r}} {% endfor %}{% else %}{% for c in case %}1 {% endfor %}{% for c in control %}2 {% endfor %}{% endif %}
      echo "{\"proc.progress\":0.8,\"proc.rc\":$?}"

      python -u {{ proc.slugs_path }}/gencloud-20131109/expressionmedian.py {% for c in case %}"{{c.output.exp.file}}" {% endfor %} --name Case_RPKUM_ > rpkum_median_case.tab
      gzip rpkum_median_case.tab
      echo "{\"proc.progress\":0.85,\"proc.rc\":$?}"

      python -u {{ proc.slugs_path }}/gencloud-20131109/expressionmedian.py {% for c in control %}"{{c.output.exp.file}}" {% endfor %} --name Control_RPKUM_ > rpkum_median_control.tab
      gzip rpkum_median_control.tab
      echo "{\"proc.progress\":0.9,\"proc.rc\":$?}"

      gzip diffexp_bayseq_partial.tab

      python -u {{ proc.slugs_path }}/gencloud-20131109/expressionmerge.py diffexp_bayseq_partial.tab.gz rpkum_median_case.tab.gz rpkum_median_control.tab.gz --intersection > diffexp_bayseq.tab
      echo "{\"proc.progress\":0.95,\"proc.rc\":$?}"

      if [ -f {{ proc.data_path }}/{{ proc.data_id }}/diffexp_bayseq.tab ]
      then
        gzip diffexp_bayseq.tab
        echo "{\"diffexp\":{\"file\":\"diffexp_bayseq.tab.gz\"}}"
      fi

      python -u {{ proc.slugs_path }}/gencloud-20131109/volcanoplot-bcm.py diffexp_bayseq.tab.gz
      echo "{\"proc.progress\":1,\"proc.rc\":$?}"

- name: findsimilar
  version: 1.0.5
  label: Find genes with similar expression
  type: data:similarexpression
  persistence: TEMP
  description: >
    From selected genes find genes with similar expression
  input:
    - name: etcx
      label: Expression time course
      type: data:etc
      required: true
    - name: gene
      label: query gene
      type: basic:string
      required: true
    - name: scoring_function
      required: true
      label: Scoring function
      type: basic:string
      default: pearson
      choices:
        - label: Spearman's correlation
          value: spearman
        - label: Pearson's correlation
          value: pearson
        - label: Euclidean distance
          value: euclidean
  output:
    - name: simgenes
      label: Genes with similar expression
      type: basic:json
  static:
    - name: name
      label: Name
      type: basic:string
      default: "Expression of genes similar to {{gene}}"
    - name: experiment
      label: Experiment
      type: basic:string
    - name: attachments
      label: Attachments
      type: list:basic:file
    - name: tags
      label: Tags
      type: list:basic:string
      default: ["Similar expression", "JSON"]
      placeholder: new tag
    - name: description
      label: Description
      type: basic:text
      default: "Description of similar expression."
  var:
    - name: notes
      label: Notes
      type: basic:text
  run:
    runtime: polyglot
    bash: |
      gen-require common
      find_similar.py -g "{{gene}}" -d "{{scoring_function}}" "{{etcx.etcfile.file}}"
      gen-checkrc

- name: cufflinks:-2-2-1
  version: 1.0.6
  label: Expression (Cufflinks 2.2.1)
  type: data:cufflinks:cufflinks
  category: analyses
  persistence: CACHED
  description: >
    Assemble transcripts and estimate their abundances.
  input:
    - name: alignment
      label: Aligned reads
      type: data:alignment:bam
      required: true
    - name: gff
      label: Annotation (GTF/GFF3)
      type: data:annotation
      required: false
    - name: genome
      label: Run bias detection and correction algorithm
      type: data:genome:fasta
      required: false
      description: >
        Provide Cufflinks with a multifasta file (genome file) via this option to instruct it to run a bias detection and correction algorithm which can significantly improve accuracy of transcript abundance estimates.
    - name: mask_file
      label: Mask file
      type: data:annotation:gtf
      required: false
      description: >
        Ignore all reads that could have come from transcripts in this GTF file. We recommend including any annotated rRNA, mitochondrial transcripts other abundant transcripts you wish to ignore in your analysis in this file. Due to variable efficiency of mRNA enrichment methods and rRNA depletion kits, masking these transcripts often improves the overall robustness of transcript abundance estimates.
    - name: library_type
      required: true
      label: Library type
      type: basic:string
      description: >
        In cases where Cufflinks cannot determine the platform and protocol used to generate input reads, you can supply this information manually, which will allow Cufflinks to infer source strand information with certain protocols. The available options are listed below. For paired-end data, we currently only support protocols where reads are point towards each other: fr-unstranded - Reads from the left-most end of the fragment (in transcript coordinates) map to the transcript strand, and the right-most end maps to the opposite strand; fr-firststrand - Same as above except we enforce the rule that the right-most end of the fragment (in transcript coordinates) is the first sequenced (or only sequenced for single-end reads). Equivalently, it is assumed that only the strand generated during first strand synthesis is sequenced; fr-secondstrand - Same as above except we enforce the rule that the left-most end of the fragment (in transcript coordinates) is the first sequenced (or only sequenced for single-end reads). Equivalently, it is assumed that only the strand generated during second strand synthesis is sequenced.
      default: fr-unstranded
      choices:
        - label: fr-unstranded
          value: fr-unstranded
        - label: fr-firststrand
          value: fr-firststrand
        - label: fr-secondstrand
          value: fr-secondstrand
    - name: annotation_usage
      required: true
      label: Instruct Cufflinks how to use the provided annotation (GFF/GTF) file
      type: basic:string
      description: >
        GTF-guide - tells Cufflinks to use the supplied reference annotation (GFF) to guide RABT assembly. Reference transcripts will be tiled with faux-reads to provide additional information in assembly. Output will include all reference transcripts as well as any novel genes and isoforms that are assembled. --GTF - tells Cufflinks to use the supplied reference annotation (a GFF file) to estimate isoform expression. It will not assemble novel transcripts, and the program will ignore alignments not structurally compatible with any reference transcript.
      default: --GTF-guide
      choices:
        - label: Use supplied reference annotation to guide RABT assembly (--GTF-guide)
          value: --GTF-guide
        - label: Use supplied reference annotation to estimate isoform expression (--GTF)
          value: --GTF
    - name: multi_read_correct
      label: Do initial estimation procedure to more accurately weight reads with multiple genome mappings
      type: basic:boolean
      default: false
      description: >
        Run an initial estimation procedure that weights reads mapping to multiple locations more accurately.
    - name: threads
      label: Use this many processor threads
      type: basic:integer
      default: 1
      description: >
        Use this many threads to align reads. The default is 1.
  output:
    - name: transcripts
      label: Assembled transcript isoforms
      type: basic:file
    - name: isoforms_fpkm_tracking
      label: Isoforms FPKM tracking
      type: basic:file
    - name: genes_fpkm_tracking
      label: Genes FPKM tracking
      type: basic:file
    - name: skipped_loci
      label: Skipped loci
      type: basic:file
  static:
    - name: name
      label: Name
      type: basic:string
      default: "Cufflinks analysis ({{ alignment.output.bam.file|basename|default:'?' }})"
    - name: cite
      label: Citation
      type: list:basic:url:link
    - name: experiment
      label: Experiment
      type: basic:string
    - name: attachments
      label: Attachments
      type: list:basic:file
    - name: tags
      label: Tags
      type: list:basic:string
      default: ["expression", "Cufflinks"]
      placeholder: new tag
    - name: description
      label: Description
      type: basic:text
      default: "Description of the expression analysis."
  var:
    - name: notes
      label: Notes
      type: basic:text
  run:
    runtime: polyglot
    bash: |

      {% if genome %}

        GENOME_NAME=`basename '{{ genome.output.fasta.file }}' .fasta.gz`
        gzip -cd {{ genome.output.fasta.file }} > "${GENOME_NAME}.fasta"

      {% endif %}

      NAME=`basename '{{ alignment.output.bam.file }}' .bam`

      echo "{\"proc.progress\":0.1}"

      {{proc.slugs_path}}/cufflinks-2.2.1/cufflinks {% if gff %} '{{ annotation_usage }}' {% if gff.output.gtf.file %} "{{ gff.output.gtf.file }}" {% elif gff.output.gff.file %} "{{ gff.output.gff.file }}" {% endif %} {% endif %} {% if genome %} --frag-bias-correct "${GENOME_NAME}.fasta" {% endif %} {% if multi_read_correct %} --multi-read-correct {% endif %} {% if mask_file %} -M '{{ mask_file.output.gtf.file }}' {% endif %} --library-type '{{ library_type }}' --num-threads '{{ threads }}' --quiet '{{ alignment.output.bam.file }}'

      echo "{\"proc.progress\":0.9,\"proc.rc\":$?}"

      mv transcripts.gtf ${NAME}_transcripts.gtf
      mv isoforms.fpkm_tracking ${NAME}_isoforms_fpkm_tracking.txt
      mv genes.fpkm_tracking ${NAME}_genes_fpkm_tracking.txt
      mv skipped.gtf ${NAME}_skipped.gtf

      echo "{\"proc.progress\":1,\"transcripts\":{\"file\":\"${NAME}_transcripts.gtf\"}, \"isoforms_fpkm_tracking\":{\"file\":\"${NAME}_isoforms_fpkm_tracking.txt\"}, \"genes_fpkm_tracking\":{\"file\":\"${NAME}_genes_fpkm_tracking.txt\"}, \"skipped_loci\":{\"file\":\"${NAME}_skipped.gtf\"}}"

- name: cuffmerge:-2-2-1
  version: 1.0.9
  label: Merge Cufflinks assemblies (Cuffmerge 2.2.1)
  type: data:annotation:cuffmerge
  category: analyses
  persistence: CACHED
  description: >
    Merge together several Cufflinks assemblies
  input:
    - name: expressions
      label: Cufflinks transcripts (GTF)
      type: list:data:cufflinks:cufflinks
      required: false
    - name: gtf
      label: Annotation files (GTF)
      type: list:data:annotation:gtf
      required: false
      description: >
        Annotation files you wish to merge together with Cufflinks produced annotation files (e.g. upload Cufflinks annotation GTF file)
    - name: gff
      label: Reference annotation (GTF/GFF3)
      type: data:annotation
      required: false
      description: >
        An optional "reference" annotation GTF. The input assemblies are merged together with the reference GTF and included in the final output.
    - name: genome
      label: Reference genome
      type: data:genome:fasta
      required: false
      description: >
        This argument should point to the genomic DNA sequences for the reference. If a directory, it should contain one fasta file per contig. If a multifasta file, all contigs should be present. The merge script will pass this option to cuffcompare, which will use the sequences to assist in classifying transfrags and excluding artifacts (e.g. repeats). For example, Cufflinks transcripts consisting mostly of lower-case bases are classified as repeats. Note that <seq_dir> must contain one fasta file per reference chromosome, and each file must be named after the chromosome, and have a .fa or .fasta extension
    - name: threads
      label: Use this many processor threads
      type: basic:integer
      default: 1
      description: >
        Use this many threads to align reads. The default is 1.
  output:
    - name: merged_gtf
      label: Merged GTF file
      type: basic:file
  static:
    - name: name
      label: Name
      type: basic:string
      default: 'Merged annotation (Cuffmerge)'
    - name: alias
      label: Alias
      type: basic:string
      description: Short name for the annotation file
    - name: cite
      label: Citation
      type: list:basic:url:link
    - name: experiment
      label: Experiment
      type: basic:string
    - name: attachments
      label: Attachments
      type: list:basic:file
    - name: tags
      label: Tags
      type: list:basic:string
      default: ['Cuffmerge', 'Annotation']
      placeholder: new tag
    - name: description
      label: Description
      type: basic:text
      default: 'Description of Cuffmerge results.'
  var:
    - name: notes
      label: Notes
      type: basic:text
  run:
    runtime: polyglot
    bash: |
      gen-require common
      gen-require cufflinks-2.2.1

      echo "Preparing transcript assembly list!"

      {% for exp in expressions %}
        echo '{{ exp.transcripts.file }}' >> transcript_assembly_list.txt
        gen-checkrc
      {% endfor %}

      {% for annotation in gtf %}
        echo '{{ annotation.gtf.file }}' >> transcript_assembly_list.txt
        gen-checkrc
      {% endfor %}

      gen-progress 0.1

      {% if genome %}
        GENOME_NAME=`basename '{{ genome.output.fasta.file }}' .fasta.gz`
        gzip -cd {{ genome.output.fasta.file }} > "${GENOME_NAME}.fasta"
      {% endif %}

      {% if gff.gff.file %}
        gffread '{{gff.gff.file}}' -T -o reference_annotation.gtf
        gen-checkrc "Gffread failure. GFF3 to GTF format conversion failed."
      {% endif %}

      echo "Running Cuffmerge"

      {{proc.slugs_path}}/cufflinks-2.2.1/cuffmerge {% if gff.output.gtf.file %} --ref-gtf '{{ gff.output.gtf.file }}' {% else %} --ref-gtf reference_annotation.gtf {% endif %} {% if genome %} --ref-sequence "${GENOME_NAME}.fasta" {% endif %} --num-threads '{{ threads }}' -o ./ transcript_assembly_list.txt

      gen-checkrc
      gen-progress 0.95

      mv merged.gtf cuffmerge_$(date +'%m-%d-%Y').gtf
      gen-save-file merged_gtf cuffmerge_$(date +'%m-%d-%Y').gtf

- name: cuffnorm:-2-2-1
  version: 1.0.8
  label: Expression (Cuffnorm 2.2.1)
  type: data:expressionset:cuffnorm
  category: analyses
  persistence: CACHED
  description: >
    Generate tables of expression values that are properly normalized for library size.
  input:
    - name: cuffquant
      label: Cuffquant expression file
      type: list:data:cufflinks:cuffquant
      required: true
    - name: replicates
      label: Define Groups/Replicates
      type: list:basic:string
      required: true
      description: >
        Define sample groups and/or sample replicates. For example, a string 1 1 2 2 2 will split 5 samples into 2 groups with 2 and 3 replicate samples in each group, respectively.
    - name: labels
      label: Group labels
      type: list:basic:string
      required: true
      description: >
        Define labels for each sample group. For example, for samples split into 2 groups (e.g. 1 1 2 2 2), enter two group labels (e.g. group1 group2).
    - name: gff
      label: Annotation (GTF/GFF3)
      type: data:annotation:cuffmerge
      required: true
      description: >
        A transcript annotation file produced by cufflinks, cuffcompare, or other source.
    - name: threads
      label: Use this many processor threads
      type: basic:integer
      default: 1
      description: >
        Use this many threads to align reads. The default is 1.
  output:
    - name: expset
      label: Expression set (FPKM)
      type: basic:file
    - name: cuffnorm_output
      label: Cuffnorm output
      type: basic:file
    - name: expset_type
      label: Expression set type
      type: basic:string
      default: 'Cuffnorm'
  static:
    - name: name
      label: Name
      type: basic:string
      default: 'Cuffnorm results'
    - name: alias
      label: Alias
      type: basic:string
      description: Short name for the expression analysis
    - name: cite
      label: Citation
      type: list:basic:url:link
    - name: experiment
      label: Experiment
      type: basic:string
    - name: attachments
      label: Attachments
      type: list:basic:file
    - name: tags
      label: Tags
      type: list:basic:string
      default: ['Cuffnorm', 'Expression']
      placeholder: new tag
    - name: description
      label: Description
      type: basic:text
      default: 'Description of Cuffnorm results.'
  var:
    - name: notes
      label: Notes
      type: basic:text
  run:
    runtime: polyglot
    bash: |
      export PATH=$PATH:{{ proc.slugs_path }}/cufflinks-2.2.1

      experiment=""
      labels=""
      replicates=""

      experiment='{% for experiment in cuffquant %}{{ experiment.output.abundances.file }},{% endfor %}'

      {% for r in replicates %}
        replicates=$replicates"{{r}},"
      {% endfor %}

      {% for l in labels %}
        labels=$labels"{{l}},"
      {% endfor %}

      labels=${labels%?}
      experiment=${experiment%?}
      replicates=${replicates%?}

      experiments=`python -u {{ proc.slugs_path }}/gencloud-20131109/cufflinks_sample_groups.py ${experiment} ${replicates}`

      echo "{\"proc.progress\":0.1}"

      {{proc.slugs_path}}/cufflinks-2.2.1/cuffnorm --output-dir ./ --num-threads '{{ threads }}' --output-format cuffdiff --labels ${labels} '{{ gff.output.merged_gtf.file }}' ${experiments}

      echo "{\"proc.progress\":0.80,\"proc.rc\":$?}"

      python -u {{ proc.slugs_path }}/gencloud-20131109/parse_cuffnorm.py "isoforms.fpkm_tracking"

      echo "{\"proc.progress\":0.90,\"proc.rc\":$?}"

      gzip expression_set.tsv
      zip cuffnorm_output_$(date +'%m-%d-%Y').zip cds.* isoforms.* genes.* tss_groups* read_groups.info run.info

      echo "{\"proc.progress\":1,\"expset\":{\"file\":\"expression_set.tsv.gz\"}, \"cuffnorm_output\":{\"file\":\"cuffnorm_output_$(date +'%m-%d-%Y').zip\"}}"

- name: cuffdiff:-2-2-1
  version: 1.0.8
  label: Differential Expression (Cuffdiff 2.2.1)
  type: data:differentialexpression:cuffdiff
  category: analyses
  persistence: CACHED
  description: >
    Find significant changes in transcript expression, splicing, and promoter use.
  input:
    - name: cuffquant
      label: Cuffquant expression file
      type: list:data:cufflinks:cuffquant
      required: true
    - name: replicates
      label: Define Groups/Replicates
      type: list:basic:string
      required: true
      description: >
        Define sample groups and/or sample replicates. For example, a string 1 1 2 2 2 will split 5 samples into 2 groups with 2 and 3 replicate samples in each group, respectively.
    - name: labels
      label: Group labels
      type: list:basic:string
      required: true
      description: >
        Define labels for each sample group. For example, for samples split into 2 groups (e.g. 1 1 2 2 2), enter two group labels (e.g. group1 group2)
    - name: gff
      label: Annotation (GTF/GFF3)
      type: data:annotation:cuffmerge
      required: true
      description: >
        A transcript annotation file produced by cufflinks, cuffcompare, or other source.
    - name: genome
      label: Run bias detection and correction algorithm
      type: data:genome:fasta
      required: false
      description: >
        Provide Cufflinks with a multifasta file (genome file) via this option to instruct it to run a bias detection and correction algorithm which can significantly improve accuracy of transcript abundance estimates.
    - name: multi_read_correct
      label: Do initial estimation procedure to more accurately weight reads with multiple genome mappings
      type: basic:boolean
      default: false
    - name: time_series
      label: Analyze the provided samples as a time series
      type: basic:boolean
      required: false
      default: false
      description: >
        Instructs Cuffdiff to analyze the provided samples as a time series, rather than testing for differences between all pairs of samples. Samples should be provided in increasing time order at the command line (e.g first time point SAM, second timepoint SAM, etc.).
    - name: fdr
      label: Allowed FDR
      type: basic:decimal
      required: true
      default: 0.05
      description: >
        The allowed false discovery rate. The default is 0.05.
    - name: library_type
      required: true
      label: Library type
      type: basic:string
      description: >
        In cases where Cufflinks cannot determine the platform and protocol used to generate input reads, you can supply this information manually, which will allow Cufflinks to infer source strand information with certain protocols. The available options are listed below. For paired-end data, we currently only support protocols where reads are point towards each other: fr-unstranded - Reads from the left-most end of the fragment (in transcript coordinates) map to the transcript strand, and the right-most end maps to the opposite strand; fr-firststrand - Same as above except we enforce the rule that the right-most end of the fragment (in transcript coordinates) is the first sequenced (or only sequenced for single-end reads). Equivalently, it is assumed that only the strand generated during first strand synthesis is sequenced; fr-secondstrand - Same as above except we enforce the rule that the left-most end of the fragment (in transcript coordinates) is the first sequenced (or only sequenced for single-end reads). Equivalently, it is assumed that only the strand generated during second strand synthesis is sequenced.
      default: fr-unstranded
      choices:
        - label: fr-unstranded
          value: fr-unstranded
        - label: fr-firststrand
          value: fr-firststrand
        - label: fr-secondstrand
          value: fr-secondstrand
    - name: library_normalization
      required: true
      label: Library normalization method
      type: basic:string
      description: >
        You can control how library sizes (i.e. sequencing depths) are normalized in Cufflinks and Cuffdiff. Cuffdiff has several methods that require multiple libraries in order to work. Library normalization methods supported by Cufflinks work on one library at a time.
      default: geometric
      choices:
        - label: geometric
          value: geometric
        - label: classic-fpkm
          value: classic-fpkm
        - label: quartile
          value: quartile
    - name: dispersion_method
      required: true
      label: Dispersion method
      type: basic:string
      description: >
        Cuffdiff works by modeling the variance in fragment counts across replicates as a function of the mean fragment count across replicates. Strictly speaking, models a quantitity called dispersion - the variance present in a group of samples beyond what is expected from a simple Poisson model of RNA_Seq. You can control how Cuffdiff constructs its model of dispersion in locus fragment counts. Each condition that has replicates can receive its own model, or Cuffdiff can use a global model for all conditions. All of these policies are identical to those used by DESeq (Anders and Huber, Genome Biology, 2010).
      default: pooled
      choices:
        - label: pooled
          value: pooled
        - label: per-condition
          value: per-condition
        - label: blind
          value: blind
        - label: poisson
          value: poisson
    - name: threads
      label: Use this many processor threads
      type: basic:integer
      default: 1
      description: >
        Use this many threads to align reads. The default is 1.
  output:
    - name: diffexp
      label: Differential expression (transcript level)
      type: basic:file
    - name: gene_diff_exp
      label: Differential expression (gene level)
      type: basic:file
    - name: tss_group_diff_exp
      label: Differential expression (primary transcript)
      type: basic:file
    - name: cds_diff_exp
      label: Differential expression (coding sequence)
      type: basic:file
    - name: cuffdiff_output
      label: Cuffdiff output
      type: basic:file
  static:
    - name: name
      label: Name
      type: basic:string
      default: Cuffdiff results
    - name: alias
      label: Alias
      type: basic:string
      description: Short name for the DE analysis
    - name: cite
      label: Citation
      type: list:basic:url:link
    - name: experiment
      label: Experiment
      type: basic:string
    - name: attachments
      label: Attachments
      type: list:basic:file
    - name: tags
      label: Tags
      type: list:basic:string
      default: ['Cuffdiff', 'Differential Expression']
      placeholder: new tag
    - name: description
      label: Description
      type: basic:text
      default: Description of Cuffdiff differential expression analysis results.
  var:
    - name: notes
      label: Notes
      type: basic:text
  run:
    runtime: polyglot
    bash: |
      export PATH=$PATH:{{ proc.slugs_path }}/cufflinks-2.2.1

      experiment=""
      labels=""
      replicates=""

      {% for experiment in cuffquant %}
        experiment=$experiment"{{ experiment.output.abundances.file }},"
        echo "{\"proc.rc\":$?}"
      {% endfor %}

      {% for r in replicates %}
        replicates=$replicates"{{r}},"
      {% endfor %}

      {% for l in labels %}
        labels=$labels"{{l}},"
      {% endfor %}

      labels=${labels%?}
      experiment=${experiment%?}
      replicates=${replicates%?}

      experiments=`python -u {{ proc.slugs_path }}/gencloud-20131109/cufflinks_sample_groups.py ${experiment} ${replicates}`

      {% if genome %}

        GENOME_NAME=`basename '{{ genome.output.fasta.file }}' .fasta.gz`
        gzip -cd {{ genome.output.fasta.file }} > "${GENOME_NAME}.fasta"

      {% endif %}

      echo "{\"proc.progress\":0.1}"

      {{proc.slugs_path}}/cufflinks-2.2.1/cuffdiff -output-dir ./ -num-threads '{{ threads }}' -labels ${labels} {% if genome %} -frag-bias-correct "${GENOME_NAME}.fasta" {% endif %} {% if multi_read_correct %} -multi-read-correct {% endif %} {% if time_series %} -time-series {% endif %} -FDR '{{ fdr }}' -library-type '{{ library_type }}' -library-norm-method '{{ library_normalization }}' -dispersion-method '{{ dispersion_method }}' -quiet '{{ gff.output.merged_gtf.file }}' ${experiments}

      echo "{\"proc.progress\":0.95,\"proc.rc\":$?}"

      gzip -c cds_exp.diff > cds_exp_$(date +'%m-%d-%Y').diff.gz
      gzip -c gene_exp.diff > gene_exp_$(date +'%m-%d-%Y').diff.gz
      gzip -c isoform_exp.diff > isoform_exp_$(date +'%m-%d-%Y').diff.gz
      gzip -c tss_group_exp.diff > tss_group_exp_$(date +'%m-%d-%Y').diff.gz

      zip cuffdiff_output_$(date +'%m-%d-%Y').zip cds.* isoforms.* genes.* tss_groups.* read_groups.* promoters.diff splicing.diff cds_exp.diff gene_exp.diff isoform_exp.diff tss_group_exp.diff

      echo "{\"proc.progress\":1,\"cds_diff_exp\":{\"file\":\"cds_exp_$(date +'%m-%d-%Y').diff.gz\"}, \"gene_diff_exp\":{\"file\":\"gene_exp_$(date +'%m-%d-%Y').diff.gz\"}, \"diffexp\":{\"file\":\"isoform_exp_$(date +'%m-%d-%Y').diff.gz\"}, \"tss_group_diff_exp\":{\"file\":\"tss_group_exp_$(date +'%m-%d-%Y').diff.gz\"}, \"cuffdiff_output\":{\"file\":\"cuffdiff_output_$(date +'%m-%d-%Y').zip\"}}"

- name: htseq-count:-0-6-1p1
  version: 1.0.8
  label: Expression (HTSeq-count 0.6.1p1)
  type: data:expression:htseq
  category: analyses
  persistence: CACHED
  description: >
    Count the number of reads that map to a genomic feature (e.g. gene)
  input:
    - name: alignments
      label: Aligned reads
      type: data:alignment:bam
      required: true
    - name: gff
      label: Annotation (GFF)
      type: data:annotation:gtf
      required: true
    - name: mode
      label: Mode
      type: basic:string
      required: true
      description: >
        Mode to handle reads overlapping more than one feature. Possible values for <mode> are union, intersection-strict and intersection-nonempty
      default: union
      choices:
        - label: union
          value: union
        - label: intersection-strict
          value: intersection-strict
        - label: intersection-nonempty
          value: intersection-nonempty
    - name: stranded
      label: Is data from a strand specific assay?
      type: basic:string
      required: true
      description: >
        For stranded=no, a read is considered overlapping with a feature regardless of whether it is mapped to the same or the opposite strand as the feature. For stranded=yes and single-end reads, the read has to be mapped to the same strand as the feature. For paired-end reads, the first read has to be on the same strand and the second read on the opposite strand. For stranded=reverse, these rules are reversed
      default: "yes"
      choices:
        - label: "yes"
          value: "yes"
        - label: "no"
          value: "no"
        - label: reverse
          value: reverse
    - name: feature_type
      label: Feature type
      type: basic:string
      default: exon
      description: >
        Feature type (3rd column in GFF file) to be used, all features of other type are ignored.
    - name: id_attribute
      label: ID attribute
      type: basic:string
      default: gene_id
      description: >
        GFF attribute to be used as feature ID. Several GFF lines with the same feature ID will be considered as parts of the same feature. The feature ID is used to identity the counts in the output table.
    - name: name_ordered
      label: Use name-ordered BAM file for counting reads
      type: basic:boolean
      default: false
      required: false
      description: >
        Use name-sorted BAM file for reads quantification. Improves compatibility with larger BAM files, but requires more computational time.
  output:
    - name: htseq_output
      label: HTseq-count output
      type: basic:file
    - name: rc
      label: Read counts
      type: basic:file
    - name: fpkm
      label: FPKM
      type: basic:file
    - name: exp
      label: TPM (Transcripts Per Million)
      type: basic:file
    - name: exp_json
      label: TPM (json)
      type: basic:json
    - name: exp_type
      label: Expression Type (default output)
      type: basic:string
      default: TPM
  static:
    - name: name
      label: Name
      type: basic:string
      default: "{{ alignments.output.bam.file|basename|default:'?' }}"
    - name: cite
      label: Citation
      type: list:basic:url:link
    - name: alias
      label: Alias
      type: basic:string
      description: Short name for the expression analysis
    - name: experiment
      label: Experiment
      type: basic:string
    - name: attachments
      label: Attachments
      type: list:basic:file
    - name: tags
      label: Tags
      type: list:basic:string
      default: ['HTSeq-count', 'Expression', 'FPKM', 'TPM']
      placeholder: new tag
    - name: description
      label: Description
      type: basic:text
      default: HTSeq-count analysis
  var:
    - name: notes
      label: Notes
      type: basic:text
  run:
    runtime: polyglot
    bash: |
      gen-require common
      gen-require samtools-0.1.19

      NAME=`basename '{{ alignments.output.bam.file }}' .bam`
      gen-progress 0.1

      {% if name_ordered %}
        if samtools view -H '{{ alignments.output.bam.file }}' | grep SO:queryname; then
          htseq-count --format=bam --order=name --stranded='{{ stranded }}' --mode='{{mode}}' --type='{{ feature_type }}' --idattr='{{ id_attribute }}' '{{ alignments.output.bam.file }}' "{{ gff.output.gtf.file }}" > "HTseq_rc.txt"
        else
          echo "Name sorting aligned reads:"
          samtools sort -n '{{ alignments.output.bam.file }}' "${NAME}_name_sorted"
          gen-checkrc
          gen-progress 0.5
          htseq-count --format=bam --order=name --stranded='{{ stranded }}' --mode='{{mode}}' --type='{{ feature_type }}' --idattr='{{ id_attribute }}' ${NAME}_name_sorted.bam "{{ gff.output.gtf.file }}" > "HTseq_rc.txt"
        fi
      {% else %}
        htseq-count --format=bam --order=pos --stranded='{{ stranded }}' --mode='{{mode}}' --type='{{ feature_type }}' --idattr='{{ id_attribute }}' '{{ alignments.output.bam.file }}' "{{ gff.output.gtf.file }}" > "HTseq_rc.txt"
      {% endif %}

      gen-checkrc
      gen-progress 0.8

      head -n -5 HTseq_rc.txt > rc_wo_header.txt
      expression_fpkm_tpm.R  '{{ gff.output.gtf.file }}' '{{ feature_type }}' '{{ id_attribute }}' 'rc_wo_header.txt'
      gen-checkrc
      gen-progress 0.9

      add_header.py rc_wo_header.txt rc.txt
      add_header.py fpkm_wo_header.tab fpkm.tab
      add_header.py tpm_wo_header.tab tpm.tab

      gzip -c HTseq_rc.txt > ${NAME}_HTseq_rc.txt.gz
      gzip -c rc.txt > ${NAME}_rc.tab.gz
      gzip -c fpkm.tab > ${NAME}_fpkm.tab.gz
      gzip -c tpm.tab > ${NAME}_tpm.tab.gz

      expression2storage.py ${NAME}_tpm.tab.gz

      gen-checkrc
      gen-progress 0.95

      gen-save-file rc "${NAME}_rc.tab.gz"
      gen-save-file fpkm "${NAME}_fpkm.tab.gz"
      gen-save-file exp "${NAME}_tpm.tab.gz"
      gen-save-file htseq_output "${NAME}_HTseq_rc.txt.gz"

- name: cuffquant:-2-2-1
  version: 1.0.4
  label: Expression (Cuffquant 2.2.1)
  type: data:cufflinks:cuffquant
  category: analyses
  persistence: CACHED
  description: >
    Compute the gene and transcript expression profiles and save these profiles to files that you can analyze later with Cuffdiff or Cuffnorm
  input:
    - name: alignment
      label: Aligned reads
      type: data:alignment:bam
      required: true
    - name: gff
      label: Annotation (GTF/GFF3)
      type: data:annotation
      required: true
    - name: genome
      label: Run bias detection and correction algorithm
      type: data:genome:fasta
      required: false
      description: >
        Provide Cufflinks with a multifasta file (genome file) via this option to instruct it to run a bias detection and correction algorithm which can significantly improve accuracy of transcript abundance estimates.
    - name: mask_file
      label: Mask file
      type: data:annotation:gtf
      required: false
      description: >
        Ignore all reads that could have come from transcripts in this GTF file. We recommend including any annotated rRNA, mitochondrial transcripts other abundant transcripts you wish to ignore in your analysis in this file. Due to variable efficiency of mRNA enrichment methods and rRNA depletion kits, masking these transcripts often improves the overall robustness of transcript abundance estimates.
    - name: library_type
      required: true
      label: Library type
      type: basic:string
      description: >
        In cases where Cufflinks cannot determine the platform and protocol used to generate input reads, you can supply this information manually, which will allow Cufflinks to infer source strand information with certain protocols. The available options are listed below. For paired-end data, we currently only support protocols where reads are point towards each other: fr-unstranded - Reads from the left-most end of the fragment (in transcript coordinates) map to the transcript strand, and the right-most end maps to the opposite strand; fr-firststrand - Same as above except we enforce the rule that the right-most end of the fragment (in transcript coordinates) is the first sequenced (or only sequenced for single-end reads). Equivalently, it is assumed that only the strand generated during first strand synthesis is sequenced; fr-secondstrand - Same as above except we enforce the rule that the left-most end of the fragment (in transcript coordinates) is the first sequenced (or only sequenced for single-end reads). Equivalently, it is assumed that only the strand generated during second strand synthesis is sequenced.
      default: fr-unstranded
      choices:
        - label: fr-unstranded
          value: fr-unstranded
        - label: fr-firststrand
          value: fr-firststrand
        - label: fr-secondstrand
          value: fr-secondstrand
    - name: multi_read_correct
      label: Do initial estimation procedure to more accurately weight reads with multiple genome mappings
      type: basic:boolean
      default: false
      description: >
        Run an initial estimation procedure that weights reads mapping to multiple locations more accurately.
    - name: threads
      label: Use this many processor threads
      type: basic:integer
      default: 1
      description: >
        Use this many threads to align reads. The default is 1.
  output:
    - name: abundances
      label: Abundances
      type: basic:file
  static:
    - name: name
      label: Name
      type: basic:string
      default: "Cuffquant expression ({{ alignment.output.bam.file|basename|default:'?' }})"
    - name: cite
      label: Citation
      type: list:basic:url:link
    - name: experiment
      label: Experiment
      type: basic:string
    - name: attachments
      label: Attachments
      type: list:basic:file
    - name: tags
      label: Tags
      type: list:basic:string
      default: ["expression", "Cuffquant"]
      placeholder: new tag
    - name: description
      label: Description
      type: basic:text
      default: "Description of the expression analysis."
  var:
    - name: notes
      label: Notes
      type: basic:text
  run:
    runtime: polyglot
    bash: |

      {% if genome %}

        GENOME_NAME=`basename '{{ genome.output.fasta.file }}' .fasta.gz`
        gzip -cd {{ genome.output.fasta.file }} > "${GENOME_NAME}.fasta"

      {% endif %}

      NAME=`basename '{{ alignment.output.bam.file }}' .bam`

      echo "{\"proc.progress\":0.1}"

      {{proc.slugs_path}}/cufflinks-2.2.1/cuffquant {% if genome %} --frag-bias-correct "${GENOME_NAME}.fasta" {% endif %} {% if multi_read_correct %} "--multi-read-correct" {% endif %} {% if mask_file %} -M '{{ mask_file.output.gtf.file }}' {% endif %} --library-type '{{ library_type }}' --num-threads '{{ threads }}' --quiet {% if gff.output.gtf.file %} '{{ gff.output.gtf.file }}' {% elif gff.output.gff.file %} '{{ gff.output.gff.file }}' {% elif gff.output.merged_gtf.file %} '{{ gff.output.merged_gtf.file }}' {% endif %} '{{ alignment.output.bam.file }}'

      echo "{\"proc.progress\":0.9,\"proc.rc\":$?}"

      mv abundances.cxb ${NAME}_abundances.cxb

      echo "{\"proc.progress\":1,\"abundances\":{\"file\":\"${NAME}_abundances.cxb\"}}"

- name: differentialexpression:deseq2
  version: 1.0.5
  label: Differential Expression (DESeq2)
  type: data:differentialexpression:deseq2
  category: analyses
  persistence: CACHED
  description: >
    Find differentially expressed genes.
  input:
    - name: case
      label: Case
      type: list:data:expression
      required: true
      description: >
        Case samples (replicates)
    - name: control
      label: Control
      type: list:data:expression
      required: true
      description: >
        Control samples (replicates)
  output:
    - name: diffexp
      label: Differential expression
      type: basic:file
    - name: volcano_plot
      label: Volcano plot
      type: basic:json
    - name: ma_plot
      label: MA plot
      type: basic:file
  static:
    - name: name
      label: Name
      type: basic:string
      default: 'Differential expression (case vs. control)'
    - name: alias
      label: Alias
      type: basic:string
      description: Short name for the DE analysis
    - name: cite
      label: Citation
      type: list:basic:url:link
    - name: experiment
      label: Experiment
      type: basic:string
    - name: attachments
      label: Attachments
      type: list:basic:file
    - name: tags
      label: Tags
      type: list:basic:string
      default: ["differential", "expression", "DESeq2"]
      placeholder: new tag
    - name: description
      label: Description
      type: basic:text
      default: "Description of the differential expression."
  var:
    - name: notes
      label: Notes
      type: basic:text
  run:
    runtime: polyglot
    bash: |
      gen-require common
      {% for c in control %}
        {% if not c.output.rc.file %}
          gen-error "Read counts are required when using DESeq2"
        {% endif %}
        controls=$controls"{{c.rc.file}} "
        sampleConditions=$sampleConditions"control "
      {% endfor %}

      {% for t in case %}
        {% if not t.rc.file %}
          gen-error "Read counts are required when using DESeq2"
        {% endif %}
        {% if t not in control %}
          cases=$cases"{{t.rc.file}} "
          sampleConditions=$sampleConditions"case "
        {% else %}
          gen-error "DE analysis failed. Case and Control groups must contain unique samples."
        {% endif %}
      {% endfor %}

      sampleConditions=${sampleConditions%?}
      cases=${cases%?}
      sampleFiles=$controls"$cases"

      gen-progress 0.1

      expressionmerge.py ${sampleFiles} --experiments ${sampleFiles} --intersection --out 'counts.tab'
      gen-checkrc "Error merging read counts."

      run_deseq2.R counts.tab --sampleConditions ${sampleConditions}
      gen-checkrc "Error computing differential expression (DESeq2)."

      gen-progress 0.95

      python -u {{ proc.slugs_path }}/gencloud-20131109/volcanoplot.py 'diffexp_deseq2.tab'

      gzip 'diffexp_deseq2.tab'
      mv Rplots.pdf DESeq2_MAplot.pdf

      gen-save-file diffexp diffexp_deseq2.tab.gz
      gen-save-file ma_plot DESeq2_MAplot.pdf

- name: kallisto:index
  version: 1.0.1
  label: Expression (Kallisto - Index)
  type: data:index:kallisto
  category: analyses
  persistence: CACHED
  description: >
    Build Kallisto index.
  input:
    - name: fasta
      label: cDNA sequences
      type: data:seq:nucleotide
      required: true
    - name: kmer_size
      label: Kmer size
      type: basic:integer
      required: false
      description: >
        k-mer (odd) length (default: 31, max value: 31)
  output:
    - name: index
      label: Kallisto index
      type: basic:file
  static:
    - name: name
      label: Name
      type: basic:string
      default: Kallisto index ({{ fasta.fasta.file|basename|default:'?' }})
    - name: alias
      label: Alias
      type: basic:string
    - name: cite
      label: Citation
      type: list:basic:url:link
    - name: experiment
      label: Experiment
      type: basic:string
    - name: attachments
      label: Attachments
      type: list:basic:file
    - name: tags
      label: Tags
      type: list:basic:string
      default: ["Kallisto", "index"]
      placeholder: new tag
    - name: description
      label: Description
      type: basic:text
  var:
    - name: notes
      label: Notes
      type: basic:text
  run:
    runtime: polyglot
    bash: |
      gen-require common
      gen-require kallisto-0.42.1

      NAME=`basename '{{ fasta.fasta.file }}' .fasta.gz`

      kallisto index -i ${NAME} {% if kmer_size %} -k {{kmer_size}} {% endif %} {{fasta.fasta.file}}
      gen-checkrc
      gen-progress 0.9

      gen-save-file index ${NAME}

- name: kallisto:quant
  version: 1.0.1
  label: Expression (Kallisto - Quant)
  type: data:expression:kallisto
  category: analyses
  persistence: CACHED
  description: >
    Expression analysis - Kallisto.
  input:
    - name: reads
      label: Reads
      type: data:reads:fastq
      required: true
    - name: transcriptome
      label: Reference transcriptome index
      type: data:index:kallisto
      required: true
      description: >
        Reference transcriptome index produced by Kallisto indexing tool.
    - name: options
      label: Options
      group:
        - name: single
          label: Single-end reads
          type: basic:boolean
          default: false
          description: >
            Quantify single-end reads.
        - name: fragment_length_single
          label: Average fragment length (single-end)
          type: basic:decimal
          required: false
          hidden: "options.single != true"
          description: >
            Estimated average fragment length (default: value is estimated from the input data).
        - name: fragment_length_paired
          label: Average fragment length
          type: basic:decimal
          required: false
          hidden: "options.single != false"
          description: >
            Estimated average fragment length (default: for paired-end samples, value is estimated from the input data).
        # - name: bias
        #   label: Bias correction
        #   type: basic:boolean
        #   default: false
        #   description: >
        #     Perform sequence based bias correction.
    - name: bootstrap
      label: Bootstrap options
      group:
        - name: bootstrap
          label: Bootstrap samples
          type: basic:boolean
          default: false
          description: >
            Bootstrap samples
        - name: bootstrap_samples
          label: Number of bootstrap samples
          type: basic:integer
          hidden: "bootstrap.bootstrap === false"
          default: 0
          description: >
            Number of bootstrap samples (default: 0).
        - name: threads
          label: --threads
          type: basic:integer
          required: true
          default: 1
          hidden: "bootstrap.bootstrap === false"
          description: >
            Number of threads to use for bootstraping (default: 1).
        - name: seed
          label: --seed
          type: basic:integer
          required: true
          default: 42
          hidden: "bootstrap.bootstrap === false"
          description: >
            Seed for the bootstrap sampling (default: 42).
  output:
    - name: abundance
      label: Abundance
      type: basic:file
    - name: abundance_h5
      label: Abundance (h5)
      type: basic:file
    - name: bs_abundance
      label: Bootstrap abundances
      type: basic:file
    - name: exp
      label: TPM (Transcripts Per Million)
      type: basic:file
    - name: rc
      label: Read counts estimate
      type: basic:file
    - name: exp_json
      label: TPM (json)
      type: basic:json
    - name: exp_type
      label: Expression type
      type: basic:string
      default: "TPM"
  static:
    - name: name
      label: Name
      type: basic:string
      default: Expression anaysis ({{ reads.fastq.file|basename|default:'?' }})
    - name: alias
      label: Alias
      type: basic:string
    - name: cite
      label: Citation
      type: list:basic:url:link
    - name: experiment
      label: Experiment
      type: basic:string
    - name: attachments
      label: Attachments
      type: list:basic:file
    - name: tags
      label: Tags
      type: list:basic:string
      default: ["Kallisto"]
      placeholder: new tag
    - name: description
      label: Description
      type: basic:text
  var:
    - name: notes
      label: Notes
      type: basic:text
  run:
    runtime: polyglot
    bash: |
      gen-require common
      gen-require kallisto-0.42.1
      gen-progress 0.1

      {% if reads.type|subtype:'data:reads:fastq:single:' %}
        {% if not options.single %}
          gen-error "Options 'Single-end reads' and 'Average fragment length' must be supplied for single-end reads"
        {% endif %}
      {% endif %}

      {% if options.single %}
        {% if not options.fragment_length_single %}
          gen-error "Average fragment length must be supplied for single-end reads"
        {% endif %}
      {% endif %}

      {% if bootstrap.bootstrap_samples < 0 %}
          gen-error "Number of bootstrap samples must be a non-negative integer"
      {% endif %}

      {% if reads.type|subtype:'data:reads:fastq:single:' %}
        kallisto quant -i '{{ transcriptome.index.file }}' -o . --single -l '{{options.fragment_length_single}}' {{reads.fastq.file}} {% if bootstrap.bootstrap %} -b '{{bootstrap.bootstrap_samples}}' -t '{{bootstrap.threads}}' --seed '{{bootstrap.seed}}' {% endif %} '{{reads.fastq.file}}'
        gen-checkrc
        gen-progress 0.7
      {% else %}
        kallisto quant -i '{{ transcriptome.index.file }}' -o . {% if options.fragment_length_paired %} -l '{{options.fragment_length_paired}}' {% endif %} {% if bootstrap.bootstrap %} -b '{{bootstrap.bootstrap_samples}}' -t '{{bootstrap.threads}}' --seed '{{bootstrap.seed}}' {% endif %} '{{reads.fastq.file}}' '{{reads.fastq2.file}}'
        gen-checkrc
        gen-progress 0.7
      {% endif %}

      kallisto h5dump -o . abundance.h5
      gen-checkrc
      gen-progress 0.9

      parse_kallisto_output.py abundance.txt
      gen-checkrc

      gzip abundance.txt
      gzip abundance_rc.tab
      gzip abundance_tpm.tab

      expression2storage.py abundance_tpm.tab.gz
      gen-checkrc

      gen-save-file abundance_h5 abundance.h5
      gen-save-file abundance abundance.txt.gz
      gen-save-file rc abundance_rc.tab.gz
      gen-save-file exp abundance_tpm.tab.gz

      {% if bootstrap.bootstrap %}
        tar -zcvf bs_abundances.tar.gz bs_abundance*
        gen-save-file bs_abundance bs_abundances.tar.gz
      {% endif %}
